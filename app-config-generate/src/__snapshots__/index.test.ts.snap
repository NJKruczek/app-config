// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Flow File Generation creates a simple flow file 1`] = `
Array [
  "// @flow",
  "",
  "// AUTO GENERATED CODE",
  "// Run app-config with 'generate' command to regenerate this file",
  "",
  "export type Configuration = {",
  "  foo?: string;",
  "};",
  "",
]
`;

exports[`Golang File Generation creates a Go file without singleton 1`] = `
Array [
  "// @generated by app-config",
  "",
  "package main",
  "",
  "import (",
  "	\\"encoding/json\\"",
  "	\\"errors\\"",
  "	\\"fmt\\"",
  "	\\"log\\"",
  "	\\"os\\"",
  "",
  "	\\"github.com/xeipuuv/gojsonschema\\"",
  ")",
  "",
  "func LoadConfig() (Configuration, error) {",
  "	var loadedConfig Configuration",
  "	var loadedSchema map[string]interface{}",
  "	var err error",
  "",
  "	configText := os.Getenv(\\"APP_CONFIG\\")",
  "	schemaText := os.Getenv(\\"APP_CONFIG_SCHEMA\\")",
  "",
  "	if configText == \\"\\" {",
  "		return loadedConfig, errors.New(\\"The APP_CONFIG environment variable was not set\\")",
  "	}",
  "",
  "	if schemaText == \\"\\" {",
  "		return loadedConfig, errors.New(\\"The APP_CONFIG_SCHEMA environment variable was not set\\")",
  "	}",
  "",
  "	err = json.Unmarshal([]byte(schemaText), &loadedSchema)",
  "",
  "	if err != nil {",
  "		return loadedConfig, fmt.Errorf(\\"Could not parse APP_CONFIG_SCHEMA environment variable: %s\\", err.Error())",
  "	}",
  "",
  "	err = json.Unmarshal([]byte(configText), &loadedConfig)",
  "",
  "	if err != nil {",
  "		return loadedConfig, fmt.Errorf(\\"Could not parse APP_CONFIG environment variable: %s\\", err.Error())",
  "	}",
  "",
  "	schemaLoader := gojsonschema.NewGoLoader(loadedSchema)",
  "	documentLoader := gojsonschema.NewGoLoader(loadedConfig)",
  "",
  "	result, err := gojsonschema.Validate(schemaLoader, documentLoader)",
  "",
  "	if err != nil {",
  "		return loadedConfig, fmt.Errorf(\\"Could not validate App Config: %s\\", err.Error())",
  "	}",
  "",
  "	if !result.Valid() {",
  "		errors := \\"\\"",
  "",
  "		for _, desc := range result.Errors() {",
  "			if errors == \\"\\" {",
  "				errors = fmt.Sprintf(\\"%v\\", desc)",
  "			} else {",
  "				errors = fmt.Sprintf(\\"%s, %v\\", errors, desc)",
  "			}",
  "		}",
  "",
  "		return loadedConfig, fmt.Errorf(\\"The App Config value invalid: %s\\", errors)",
  "	}",
  "",
  "	return loadedConfig, nil",
  "}",
  "",
  "func UnmarshalConfiguration(data []byte) (Configuration, error) {",
  "	var r Configuration",
  "	err := json.Unmarshal(data, &r)",
  "	return r, err",
  "}",
  "",
  "func (r *Configuration) Marshal() ([]byte, error) {",
  "	return json.Marshal(r)",
  "}",
  "",
  "type Configuration struct {",
  "	Foo *string \`json:\\"foo,omitempty\\"\`",
  "}",
  "",
]
`;

exports[`Golang File Generation creates a simple Go file 1`] = `
Array [
  "// @generated by app-config",
  "",
  "package main",
  "",
  "import (",
  "	\\"encoding/json\\"",
  "	\\"errors\\"",
  "	\\"fmt\\"",
  "	\\"log\\"",
  "	\\"os\\"",
  "",
  "	\\"github.com/xeipuuv/gojsonschema\\"",
  ")",
  "",
  "var config Configuration",
  "",
  "func init() {",
  "	loadedConfig, err := LoadConfig()",
  "",
  "	if err != nil {",
  "		log.Panic(err.Error())",
  "	}",
  "",
  "	config = loadedConfig",
  "}",
  "",
  "func GetConfig() Configuration {",
  "	return config",
  "}",
  "func LoadConfig() (Configuration, error) {",
  "	var loadedConfig Configuration",
  "	var loadedSchema map[string]interface{}",
  "	var err error",
  "",
  "	configText := os.Getenv(\\"APP_CONFIG\\")",
  "	schemaText := os.Getenv(\\"APP_CONFIG_SCHEMA\\")",
  "",
  "	if configText == \\"\\" {",
  "		return loadedConfig, errors.New(\\"The APP_CONFIG environment variable was not set\\")",
  "	}",
  "",
  "	if schemaText == \\"\\" {",
  "		return loadedConfig, errors.New(\\"The APP_CONFIG_SCHEMA environment variable was not set\\")",
  "	}",
  "",
  "	err = json.Unmarshal([]byte(schemaText), &loadedSchema)",
  "",
  "	if err != nil {",
  "		return loadedConfig, fmt.Errorf(\\"Could not parse APP_CONFIG_SCHEMA environment variable: %s\\", err.Error())",
  "	}",
  "",
  "	err = json.Unmarshal([]byte(configText), &loadedConfig)",
  "",
  "	if err != nil {",
  "		return loadedConfig, fmt.Errorf(\\"Could not parse APP_CONFIG environment variable: %s\\", err.Error())",
  "	}",
  "",
  "	schemaLoader := gojsonschema.NewGoLoader(loadedSchema)",
  "	documentLoader := gojsonschema.NewGoLoader(loadedConfig)",
  "",
  "	result, err := gojsonschema.Validate(schemaLoader, documentLoader)",
  "",
  "	if err != nil {",
  "		return loadedConfig, fmt.Errorf(\\"Could not validate App Config: %s\\", err.Error())",
  "	}",
  "",
  "	if !result.Valid() {",
  "		errors := \\"\\"",
  "",
  "		for _, desc := range result.Errors() {",
  "			if errors == \\"\\" {",
  "				errors = fmt.Sprintf(\\"%v\\", desc)",
  "			} else {",
  "				errors = fmt.Sprintf(\\"%s, %v\\", errors, desc)",
  "			}",
  "		}",
  "",
  "		return loadedConfig, fmt.Errorf(\\"The App Config value invalid: %s\\", errors)",
  "	}",
  "",
  "	return loadedConfig, nil",
  "}",
  "",
  "func UnmarshalConfiguration(data []byte) (Configuration, error) {",
  "	var r Configuration",
  "	err := json.Unmarshal(data, &r)",
  "	return r, err",
  "}",
  "",
  "func (r *Configuration) Marshal() ([]byte, error) {",
  "	return json.Marshal(r)",
  "}",
  "",
  "type Configuration struct {",
  "	Foo *string \`json:\\"foo,omitempty\\"\`",
  "}",
  "",
]
`;

exports[`Rust File Generation creates a simple Rust file 1`] = `
Array [
  "use serde_derive::{Deserialize, Serialize};",
  "use valico::json_schema;",
  "",
  "#[derive(Debug, Serialize, Deserialize)]",
  "pub struct Configuration {",
  "    #[serde(rename = \\"foo\\")]",
  "    foo: Option<String>,",
  "}",
  "",
  "#[derive(Debug)]",
  "pub enum Error {",
  "    EnvironmentVariableNotFound(&'static str),",
  "    JsonParsing(serde_json::Error),",
  "    Validation(json_schema::ValidationState),",
  "}",
  "",
  "pub fn load_config() -> Result<Config, Error> {",
  "    let config_text = match std::env::var(\\"APP_CONFIG\\") {",
  "        Ok(text) => text,",
  "        Err(_) => {",
  "            return Err(Error::EnvironmentVariableNotFound(\\"APP_CONFIG\\"));",
  "        }",
  "    };",
  "",
  "    let schema_text = match std::env::var(\\"APP_CONFIG_SCHEMA\\") {",
  "        Ok(text) => text,",
  "        Err(_) => {",
  "            return Err(Error::EnvironmentVariableNotFound(\\"APP_CONFIG_SCHEMA\\"));",
  "        }",
  "    };",
  "",
  "    let config = serde_json::from_str(&config_text).map_err(Error::JsonParsing)?;",
  "    let schema = serde_json::from_str(&schema_text).map_err(Error::JsonParsing)?;",
  "",
  "    let mut scope = json_schema::Scope::new();",
  "    let schema = scope.compile_and_return(schema, false).unwrap();",
  "    let result = schema.validate(&config);",
  "",
  "    if !result.is_valid() {",
  "        return Err(Error::Validation(result));",
  "    }",
  "",
  "    return serde_json::from_value(config).map_err(Error::JsonParsing);",
  "}",
  "",
  "impl std::error::Error for Error {}",
  "",
  "impl std::fmt::Display for Error {",
  "    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {",
  "        match self {",
  "            Error::EnvironmentVariableNotFound(var) => {",
  "                write!(fmt, \\"EnvironmentVariableNotFound({})\\", var)?;",
  "            }",
  "            Error::JsonParsing(error) => {",
  "                write!(fmt, \\"JSON Parsing Error: {}\\", error)?;",
  "            }",
  "            Error::Validation(state) => {",
  "                write!(fmt, \\"JSON Schema Validation Error: {:?}\\", state)?;",
  "            }",
  "        }",
  "",
  "        Ok(())",
  "    }",
  "}",
]
`;

exports[`TypeScript File Generation corrects Date type in TypeScript files 1`] = `
"// AUTO GENERATED CODE
// Run app-config with 'generate' command to regenerate this file

import '@lcdev/app-config';

export interface MyCustomConfigName {
  x?: string;
}

// augment the default export from app-config
declare module '@lcdev/app-config' {
  export interface ExportedConfig extends MyCustomConfigName {}
}
"
`;

exports[`TypeScript File Generation creates a TypeScript file from meta file properties 1`] = `
"// AUTO GENERATED CODE
// Run app-config with 'generate' command to regenerate this file

import '@lcdev/app-config';

export interface MyCustomConfigName {
  x?: number;
}

// augment the default export from app-config
declare module '@lcdev/app-config' {
  export interface ExportedConfig extends MyCustomConfigName {}
}
"
`;

exports[`TypeScript File Generation creates a TypeScript file from schema with many $ref properties 1`] = `
"// AUTO GENERATED CODE
// Run app-config with 'generate' command to regenerate this file

import '@lcdev/app-config';

export interface Config {
  a?: A;
  root?: boolean;
}

export interface A {
  b: B;
}

export interface B {
  c: C;
}

export interface C {
  d: boolean;
}

// augment the default export from app-config
declare module '@lcdev/app-config' {
  export interface ExportedConfig extends Config {}
}
"
`;

exports[`TypeScript File Generation creates a simple TypeScript file 1`] = `
Array [
  "// AUTO GENERATED CODE",
  "// Run app-config with 'generate' command to regenerate this file",
  "",
  "import '@lcdev/app-config';",
  "",
  "export interface Configuration {",
  "  foo?: string;",
  "}",
  "",
  "// augment the default export from app-config",
  "declare module '@lcdev/app-config' {",
  "  export interface ExportedConfig extends Configuration {}",
  "}",
]
`;
